---
title: "Pydantic AI"
description: "Build type-safe agents with Pydantic AI and distributed Ray tools"
---

## When to use Pydantic AI

- You want type-safe agent development
- You prefer Pydantic's validation and schema generation
- You need structured outputs from your agents

## Create an agent

```bash
rayai create-agent my_agent --framework pydantic
```

## Define tools with `@rayai.tool`

Use `@rayai.tool` to create Ray-distributed tools that work directly with Pydantic AI:

```python
import rayai
from pydantic_ai import Agent


@rayai.tool(num_cpus=1)
def search_web(query: str) -> str:
    """Search the web for information."""
    return f"Results for: {query}"


@rayai.tool(num_cpus=2, memory="4GB")
def analyze_data(data: str) -> dict:
    """Analyze data with heavy computation."""
    return {"result": f"Analysis of {data}"}


def make_agent():
    return Agent(
        "openai:gpt-4o-mini",
        system_prompt="You are a helpful assistant.",
        tools=[search_web, analyze_data],
    )


rayai.serve(make_agent, name="my-agent", num_cpus=1, memory="2GB")
```

## Wrap existing tools

Use `rayai.tool()` as a wrapper for existing callables or framework tools:

```python
import rayai
from pydantic_ai import Agent
from langchain_community.tools import DuckDuckGoSearchRun


# Wrap a LangChain tool for Ray execution
lc_search = rayai.tool(DuckDuckGoSearchRun(), num_cpus=1)


# Wrap a plain function
def calculate(a: int, b: int) -> int:
    """Add two numbers together."""
    return a + b

ray_calculate = rayai.tool(calculate)


def make_agent():
    return Agent("openai:gpt-4o-mini", tools=[lc_search, ray_calculate])


rayai.serve(make_agent, name="calc-agent")
```

## Next steps

<CardGroup cols={2}>
  <Card title="Build from Scratch" icon="python" href="/frameworks/build-from-scratch">
    Build agents from scratch with full control
  </Card>
  <Card title="LangChain" icon="link" href="/frameworks/langchain">
    Use LangChain and LangGraph with distributed tools
  </Card>
</CardGroup>
